### 昨天有童鞋说我抄袭，那么我今天就写下那位所谓原创童鞋未写的内容

可能就是大家常说的，有人喷你说明你还在慢慢变强大。

### 很多同学甚至没听过Memcached

相信国内包括我，2012，2014年之后入行的人，使用Memcached的机会很少，90%都世界使用的redis，甚至昨天晚上我和同行去聊说memcached你们有项目用到没，大家的回答都是，这都是老课本上的内容，基本上没项目在用，用的话也是很老的项目了。但好在我第一个接手的项目缓存就是Memcached ，以及后台框架还是 ssh 记得 hibernate 自己封装的sql写法当时用的那么溜，但现在全部被mybatis干掉了，你能说什么？技术在发展，作为职业的我们就得观察动态，学习最新的技术，但万变不离其宗。

就跟很多同学问我，现在前端大把的vue 和 React 我学校还教jquery有用么？我只能说你学习的是编程思想，剩下的都是框架的使用，了解了框架的处理机制，你的转变能不香么？

### 什么是Memcached

![Memcached](https://gitee.com/stivepeim/img4mk/raw/master/20210415105426.png)

### 什么是Redis

![Redis](https://gitee.com/stivepeim/img4mk/raw/master/20210415105529.png)



与memcached相比，Redis功能更强大，更受欢迎并且得到更好的支持。Memcached只能做Redis可以做的一小部分。即使Redis的功能重叠，Redis也更好。

这也是大家为什么都使用Redis的原因

### Memcached与Redis：直接比较

两种工具都是功能强大，快速的内存中数据存储，可用作缓存。两者都可以通过缓存数据库结果，HTML片段或其他可能产生成本很高的内容来帮助加快应用程序的速度。

### 对比要点

当用于同一事物时，以下是它们如何使用原始问题的“要考虑的要点”进行比较：

- **读/写速度**：两者都非常快。基准测试因工作负载，版本和许多其他因素而异，但通常显示redis与memcached一样快或几乎一样快。我建议使用redis，但不是因为memcached速度慢。不是。

- 内存使用情况

  ：Redis更好。

  - memcached：您指定高速缓存大小，并且在插入项目时，守护程序会迅速增长到略大于该大小。除了重新启动memcached之外，从来没有真正的方法可以回收任何空间。您所有的密钥都可能过期，您可以刷新数据库，并且它仍将使用您为其配置的RAM的全部块。
  - redis：设置最大大小由您决定。Redis永远不会使用过多的内存，并且会为您提供不再使用的内存。
  - 我将100,000个〜2KB字符串（〜200MB）的随机句子存储到了两者中。Memcached RAM使用量增加到约225MB。Redis RAM使用量增加到〜228MB。刷新两次后，redis下降至〜29MB，memcached保持在〜225MB。它们在存储数据方面同样有效，但是只有一个能够回收数据。

- **磁盘I / O转储**：由于Redis在默认情况下会这样做，并且具有非常可配置的持久性，因此无疑是redis的胜利。没有第3方工具，Memcached无法将其转储到磁盘的机制。

- **可扩展性**：在需要多个实例作为缓存之前，两者都为您提供了大量的净空。Redis包含的工具可帮助您超越此范围，而memcached则不会。

### 缓存读取速度

Memcached是一个简单的易失性缓存服务器。它允许您存储键/值对，其中值限制为最大1MB的字符串。

擅长此事，但仅此而已。您可以通过它们的键以极高的速度访问这些值，这通常会使可用网络或什至是内存带宽饱和。

重新启动内存缓存后，您的数据不见了。这对于缓存很好。您不应该在其中存储任何重要内容。

如果您需要高性能或高可用性，则可以使用第三方工具，产品和服务。

### Redis

Redis可以完成与memcached相同的工作，并且可以做得更好。

Redis也可以充当缓存。它也可以存储键/值对。在redis中，它们甚至可以达到512MB。

您可以关闭持久性，并且在重新启动时也很可能会丢失数据。如果您希望缓存能够继续运行，那么重新启动也可以。实际上，这是默认设置。

它也非常快，通常受网络或内存带宽的限制。

如果一个redis / memcached实例的性能不足以满足您的工作负载，那么redis是不二之选。Redis包括[集群支持，](https://redis.io/topics/cluster-tutorial)并附带了“在盒子里”的高可用性工具（[redis-sentinel](https://redis.io/topics/sentinel)）。在过去的几年中，redis也已成为第三方工具的明确领导者。Redis Labs，Amazon等公司提供许多有用的Redis工具和服务。Redis周围的生态系统要大得多。现在，大规模部署的数量可能会大于内存缓存的数量。

### Redis 特点

Redis不仅仅是一个缓存。它是内存中的数据结构服务器。在下面，您将快速概览Redis可以做的事情，而不仅仅是像memcached这样的简单键/值缓存。Redis的*大多数*功能都是memcached无法做到的。

## 文献资料

Redis的文档比memcached的文档更好。尽管这可能是主观的，但它似乎一直在越来越真实。

[redis.io](https://redis.io/)是一个很棒的易于导航的资源。它使您可以[在浏览器中尝试Redis，](https://try.redis.io/)甚至还可以通过文档中的每个命令为您提供实时的交互式示例。

现在，redis的堆栈溢出结果是内存缓存的2倍。Google搜寻结果的2倍。提供更多语言的更易于访问的示例。更积极的发展。更积极的客户开发。这些度量可能并没有太大的意义，但结合起来可以清楚地看到，有关Redis的支持和文档越来越多，而且是最新的。

### Redis 容灾机制

默认情况下，redis使用称为快照的机制将数据持久保存到磁盘。如果您有足够的可用RAM，则可以将所有数据写入磁盘，而性能几乎不会降低。它几乎是免费的！

在快照模式下，突然崩溃可能会导致少量数据丢失。如果您绝对需要确保没有数据丢失，请放心，redis也可以使用AOF（仅附加文件）模式在后台工作。在这种持久模式下，数据可以在写入时同步到磁盘。这样可以将最大写入吞吐量降低到磁盘可以写入的速度，但是仍然应该非常快。

如果需要，有许多配置选项可以微调持久性，但是默认设置非常明智。这些选项使将Redis设置为安全，冗余的存储数据位置变得容易。这是一个*真实的*数据库。

### 数据类型丰富

Memcached仅限于字符串，但是Redis是一个数据结构服务器，可以提供许多不同的数据类型。它还提供了充分利用这些数据类型所需的命令。

### 字符串（[命令](https://redis.io/commands#string)）

简单文本或二进制值，最大可为512MB。这是唯一的数据类型redis和memcached共享，尽管memcached字符串限制为1MB。

Redis通过提供用于按位操作，位级别操作，浮点增量/减量支持，范围查询和多键操作的命令，为您提供了更多利用此数据类型的工具。Memcached不支持任何一种。

字符串对于各种用例都是有用的，这就是为什么memcached仅对这种数据类型有用的原因。

### 散列（[命令](https://redis.io/commands#hash)）

哈希有点像键值存储中的键值存储。它们在字符串字段和字符串值之间映射。使用散列的Field-> value映射比使用常规字符串的key-> value映射具有更高的空间效率。

散列可用作名称空间，或者在您要逻辑上对许多键进行分组时很有用。使用散列，您可以有效地捕获所有成员，一起使所有成员过期，一起删除所有成员，等等。对于需要将多个键/值对进行分组的用例而言，它非常有用。

哈希的一种示例用法是在应用程序之间存储用户配置文件。使用用户ID作为键存储的Redis哈希将允许您根据需要存储有关用户的数据，同时将其存储在单个键下。使用散列而不是将配置文件序列化为字符串的优点是，您可以让不同的应用程序在用户配置文件中读/写不同的字段，而不必担心一个应用程序覆盖其他应用程序所做的更改（如果您将陈旧的序列化，则可能会发生这种情况）数据）。

### 列表（[命令](https://redis.io/commands#list)）

Redis列表是字符串的有序集合。它们经过优化，可从列表的顶部或底部（又名：左侧或右侧）插入，读取或删除值。

Redis的提供许多[命令](https://redis.io/commands#list)为利用列表，包括命令到压入/弹出的项目，推/列表，截断列表之间弹出，执行范围查询等

列表使持久的，原子的队列成为可能。这些非常适合作业队列，日志，缓冲区和许多其他用例。

### 设置（[命令](https://redis.io/commands#set)）

集是唯一值的无序集合。它们经过了优化，可让您快速检查值是否在集合中，快速添加/删除值以及测量与其他集合的重叠。

这些功能非常适合访问控制列表，唯一的访问者跟踪器以及许多其他功能。大多数编程语言都有类似的东西（通常称为Set）。就是这样，只有分布式的。

Redis提供了一些[命令](https://redis.io/commands#set)来管理集合。存在诸如添加，删除和检查集合之类的显而易见的内容。因此，不太明显的命令（例如弹出/读取随机项）以及用于执行与其他集合的并集和交集的命令。

### 排序集（[命令](https://redis.io/commands#sorted_set)）

排序集也是唯一值的集合。顾名思义，这些是有序的。它们按分数排序，然后按字典顺序排序。

此数据类型已针对按分数快速查找进行了优化。获得最高，最低或介于两者之间的任何值都非常快。

如果将用户以及他们的高分添加到排序的集合中，则您将拥有完美的排行榜。随着新的高分出现，只需将他们的高分再次添加到集合中，它将重新排列排行榜。也非常适合跟踪用户上次访问的时间以及谁在您的应用程序中处于活动状态。

存储具有相同分数的值会使它们按字典顺序（按字母顺序考虑）排序。这对于自动完成功能等很有用。

许多排序的set[命令](https://redis.io/commands#sorted_set)类似于set[命令](https://redis.io/commands#sorted_set)，有时带有附加的score参数。还包括用于管理分数和按分数查询的命令。

### Redis 地理位置 GEO

Redis的具有几个[命令](https://redis.io/commands#geo)用于存储，检索，以及测量的地理数据。这包括半径查询和测量点之间的距离。

从技术上讲，Redis中的地理数据存储在已排序的集合中，因此这并不是真正的独立数据类型。它更多地是对排序集的扩展。

### 位图和HyperLogLog

像geo一样，这些也不是完全独立的数据类型。这些命令使您可以将字符串数据视为位图或超级日志。

位图是我在`Strings`下面引用的位级运算符的作用。这种数据类型是reddit最近的合作艺术项目[r / Place](https://redditblog.com/2017/04/13/how-we-built-rplace/)的基本构建块。

HyperLogLog允许您使用恒定的极少量空间以惊人的精度计算几乎无限的唯一值。仅使用〜16KB，您就可以有效地计算出网站唯一身份访问者的数量，即使该数量是数百万。

## 交易和原子性

Redis中的命令是原子性的，这意味着您可以确保在向Redis写入值后，该值对于连接到Redis的所有客户端都是可见的。无需等待该值传播。从技术上讲，memcached也是原子的，但是redis在memcached之外添加了所有这些功能，值得注意的是，所有这些其他数据类型和功能也是原子的。

尽管与关系数据库中的事务不太相同，redis也具有使用“乐观锁定”（[WATCH](https://redis.io/commands/watch) / [MULTI](https://redis.io/commands/multi) / [EXEC](https://redis.io/commands/exec)）的[事务](https://redis.io/topics/transactions)。

## 流水线

Redis提供了一个称为“[流水线](https://redis.io/topics/pipelining)”的功能。如果要执行许多redis命令，可以使用流水线将它们一次发送一次，而不是一次发送到redis。

通常，当您执行命令以进行redis或memcached时，每个命令都是一个单独的请求/响应周期。使用流水线，redis可以缓冲多个命令并一次执行所有命令，并在一次回复中对所有命令的所有响应进行响应。

这可以使您在批量导入或涉及许多命令的其他操作上实现更高的吞吐量。

## 发布/订阅

Redis具有专用于[发布/](https://redis.io/topics/pubsub)订阅[功能的](https://redis.io/topics/pubsub)[命令](https://redis.io/commands#pubsub)，从而允许Redis充当高速消息广播者。这允许单个客户端将消息发布到连接到通道的许多其他客户端。

Redis可以执行发布/订阅以及几乎所有工具。像[RabbitMQ](https://www.rabbitmq.com/)这样的专用消息代理可能在某些方面具有优势，但事实上，同一台服务器还可以为您提供持久的持久队列和您的发布/订阅工作负载可能需要的其他数据结构，因此Redis通常被证明是最好，最简单的工具为了工作。

## Lua脚本

您可以想到[lua脚本，](https://redis.io/commands/eval)例如redis自己的SQL或存储过程。它的大小不一，但这个类比大都可行。

也许您要执行Redis复杂的计算。也许您负担不起交易回滚，并且需要保证复杂过程的每一步都将自动发生。这些问题以及更多问题可以通过lua脚本解决。

整个脚本是原子执行的，因此，如果您可以使逻辑适合lua脚本，则通常可以避免弄乱乐观的锁定事务。

## 缩放比例

如上所述，redis包括对集群的内置支持，并与自己的称为的高可用性工具捆绑在一起`redis-sentinel`。

# 结论

毫不犹豫地，对于任何新项目或尚未使用memcached的现有项目，我建议在memcached上使用redis。

以上可能听起来像我不喜欢memcached。相反：它是一种功能强大，简单，稳定，成熟且经过强化的工具。甚至在某些用例中，它比redis快一点。我喜欢记忆快取。我只是认为这对未来的发展没有多大意义。

Redis可以做memcached所做的一切，通常更好。memcached的任何性能优势都是次要的且特定于工作负载。还有一些工作负载，redis会更快，redis可以做更多的工作，而memcached根本做不到。面对巨大的功能鸿沟，微小的性能差异似乎微不足道，而且两个工具是如此之快和高效，它们很可能是您不得不担心扩展的基础架构的最后一部分。

只有一种情况使memcached更有意义：将memcached用作缓存。如果您已经使用memcached进行缓存，那么在满足您需要的情况下，请继续使用它。迁移到Redis可能不值得，如果您仅将Redis用于缓存，则可能无法提供足够的好处，值得您花时间。如果memcached不能满足您的需求，那么您可能应该改用Redis。无论您需要扩展到内存缓存之外还是需要其他功能，这都是事实。

### 日常求关注，素质一键三连。

### 每周至少3篇原创文章，在被业务折磨的情况下还能留下点什么。

### 最近很喜欢的一句话 “有道无术，术尚可求。有术无道，止于术。”

![求关注](https://gitee.com/stivepeim/img4mk/raw/master/20210413150115.png)